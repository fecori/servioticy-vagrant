/*******************************************************************************
 * Copyright 2014 Barcelona Supercomputing Center (BSC)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

Three demos are currently deployed with the Virtual Appliance. They are located in the demos folder.
The following of this document describes the characteristics of each one of the demos and the components
to be used in them.

************************************************************
************************* MAP demo *************************
************************************************************
Description:
Based on user-generated data, the demo shows on a map the different temperatures 
and locations from which a user device has send updates to the platform. 
For the particular case of the stream composition, the demo can show the temperatures 
filtered by a minimum and transformed to Fahrenheit by using composite streams.

A demo video can be found at: http://youtu.be/rjnO9Tt5KQI

- Scripts and files:
	- start.sh: starts the NGINX used to serve the contents of each map
	- stop.sh: stops the NGINX used to serve the contents of each map

	- utils/api_token.txt: API token for the data generator and consumer
	- utils/SO.id: ID of the first SO to which data will be sent
	- utils/SO2.id: ID of the second SO to which data will be sent
	- utils/SO.id: ID of the third SO, used for data composition, transformation and filtering
	- utils/generate_fake_data.py: Generates a random update on SO1 and SO2. Uses the REST API.
	- utils/clear_all_udpates.sh: Removes all the data associated to the three Service Objects

	- app/index.html: Main page used to offer quick links to the four maps provided in the demo
	- app/celsius1.html: First map in the demo (more information below)
	- app/celsius2.html: Second map in the demo (more information below)
	- app/fahrenheit.html: Third map in the demo (more information below)
	- app/above70.html: Fourth map in the demo (more information below)

- Maps: 
	- Map 1: Celsius data points from user 1 
		-SOid: 1396461657731411aa73c28444ecf9a8c803e62312fd1
		-stream: data
	- Map 2: Celsius data points from user 2
		-SOid: 139879170177572ad72be6e67450c9d4d85176e02aeb1
		-stream: data
	- Map 3: Fahrenheit (transformed and merged) data points from user 1 and 2 
		-SOid: 1398788346015aa59fe5f854b4bda89647b969c51d8a4
		-stream: fahrenheit
	- Map 4: Fahrenheit (filtered) data points from user 1 and 2 only if above 70ºF
		-SOid: 1398788346015aa59fe5f854b4bda89647b969c51d8a4
		-stream: aboveSeventy

************************************************************
**************** MQTT subscription demo ********************
************************************************************

Description:
It consists of two pieces of code: the first one is a python script to send sensor updates 
on a registered ServiceObject. A listener code is also provided, which is used to subscribe
to the data updates associated to the mentioned Service Object. Whenever data is generated 
for the Service Object, it is immediately forwarded to the subscribers. In this case, MQTT 
is used for the delivery of the data.

- Scripts and files:
	- api_token.txt: API token for the data generator and consumer
	- SO.id: ID of the SO to which data will be sent and subscriptions will be placed
	- subscription.id: ID of the MQTT subscription placed on the SO
	- create_subscription.sh: Registers a subscription (already created, id: 1397487304720f3a70252eea44e60889cc564b9c4eb5e)
	- generate_update.py: Generates a random update on the user 1 map, that is forwarded to subscribers. Uses the REST API.
	- run_subscriber.sh: runs the MQTT subscriber that will receive immediate notifications whenever data is generated by the WO and received by the SO.
	- subscriber.js: NodeJS client that subscribes to the MQTT updates. Note that the platform produces a MQTT update that can be consumed from a variety of protocols: from MQTT to TCP/STOMP as this client does. There is no difference in what transport is used, as the payload received is exactly the same.
	- utils folder: some utility scripts not intended to be used for the demo


************************************************************
************* Actuation dispatching demo *******************
************************************************************

Description:
It consists of two pieces of code: the first one is a python script to invoke actuations 
on a registered ServiceObject. In particular the actuation is “reboot”. A listener code is 
also provided, which is in charge to subscribe to a MQTT topic and receive the invocation when 
it is launched. This demo showcases the use of the actuation dispatcher to deliver actuation 
invocations to the devices using MQTT as a transport.

A demo video can be found at: http://youtu.be/d0R5qYdLEQs

- Scripts and files:
	- api_token.txt: API token for the data generator and consumer
	- SO.id: ID of the SO to which actuations will be sentever data is generated by the WO and received by the SO.
	- launch_action.sh: Invokes the actuation 'reboot' on the Service Object. Displays the actuation id once the actuation is launched.
	- show_action_status.sh: Shows the current status of an initiated actuation. It requires the actuation id as a parameter.
	- update_status.sh: Updates the status of an actuation  which have been previously initiated. It emulates the behaviour of a client code associated to a physical device for which an action has been initiated. It would use a similar mechanism to keep updated the status of the actuation as it is developed. In this particular example, the REST API is used, but it could have been updated using the MQTT bridge as well.
	- subscriber.js: NodeJS client that subscribes to the actuation notifications. Plays the role of the physical device on which to invoke actuations. Note that the platform produces a MQTT update that can be consumed from a variety of protocols: from MQTT to TCP/STOMP as this client does. There is no difference in what transport is used, as the payload received is exactly the same.
	- run_subscriber.sh: runs the MQTT subscriber that will receive acutation requests whenever they are invoked through the Service Object.
	- clear_actions.sh: Removes all the actions information stored in the platform. Used to reset the status of the appliance after using it.

